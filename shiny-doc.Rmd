---
title: "Spider-Ant Walking Analysis"
author: "Andrew"
date: "February 12, 2019"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(trajr)
library(GeneCycle)
library(readr)
library(tidyverse)
library(magrittr)
library(gsubfn)

#setwd("C:/Users/Andrew Burchill/Dropbox (ASU)/Ant mimic strobing/Finished")
setwd("D:/Weaver ants/Dropbox (ASU)/Ant mimic strobing/Finished")

#Functions below
{ 
cvs_reader_func <- function(filename, stringsAsFactors = FALSE) {
  read_csv(filename,
           col_types = cols_only(frame = col_guess(), 
                                 t = col_guess(), 
                                 x = col_guess(),  
                                 y = col_guess()
           ),
           skip = 1) %>% return()
}

nobu <- function(speed.vector, fraction = 5){
  ### look for ultradian rhythms using this
  
  ################# Modified from code by Nobuaki Mizumoto
  
  da <- speed.vector
  
  N <- length(da)
  xmean <- mean(da)
  how.long <- round(N / fraction) #don't want it to have less than 5 cycles
  
  #qp1per is Qp 1%. for statistical significant. can also use 5%
  P = Qp1per = Qp = rep(0, how.long - 1)    
  for (j in 2:how.long) {
    P[j - 1] <- j  #P is the period
    
    #divides the data into a matrix with j-1 rows
    #I don't want it to keep saying 'data length is not a sub-multiple or multiple of the number of rows'
    suppressWarnings(   
      rhythm.tab <- matrix(da, ncol = P[j - 1], byrow = T)
    )   
    y <- rep(0, P[j - 1])
    for (i in 1:P[j - 1]) {
      y[i] <- mean(rhythm.tab[, i])   #this, like, averages each col?
    }
    K <- length(rhythm.tab[, 1])
    
    Qp[j - 1] <- K * N * sum((y - xmean) ^ 2) / sum((da - xmean) ^ 2)
    Qp1per[j - 1] <- qchisq(0.99, P[j - 1] - 1)
  }
  res <- data.frame(P = P, Qp1per = Qp1per, Qp = Qp)
  
  diff <- Qp - Qp1per
  
  biggest <- P[diff == max(diff)] / 240  #divide by 240 SECONDS fps
  
  #par(pin = c(4, 3))
  plot(P / 240, Qp, type = "l", xlab = "time (second)")
  points(P / 240, Qp1per, type = "l", col = 2)
  abline(v = biggest, col = "blue")
  
  
  return(max(diff))
  
  
  #find top 5% of points
  #perc <- 5
  #which(diff > quantile(diff, prob = 1 - perc/100))
  
  
}

intervaler <- function(traj, greatthan = 0, ps = 1, ns = 7,
                       cutoffspeed = 0.05, display = FALSE) {
  filename <- attr(traj, "filename")
  
  #calculate the intervals of stopping
  traj %>%
    TrajSmoothSG(p = ps, n = ns) %>% 
    TrajSpeedIntervals(slowerThan = cutoffspeed) -> intervals 
  plot(intervals, main = filename)
  
  #calculate the intervals of MOVING (less used)
  traj %>%
    TrajSmoothSG(p = ps, n = ns) %>% 
    TrajSpeedIntervals(fasterThan = cutoffspeed) -> REVERSEintervals 
  
  #print the number of intervals of each type
  if (display) print(
    paste0(
      "stopped intervals: ", length(intervals$duration),
      ". MOVING intervals: ", length(REVERSEintervals$duration)
    ))
  
  #stop if there aren't enough intervals
  if (nrow(intervals) > 1 & nrow(REVERSEintervals) > 1) {
    
    #get the "frequencies" of stop-start "waves"
    freqs <- intervals$startTime %>% diff() %>% magrittr::extract(. > greatthan)
    
    #then get the durations of stops and starts
    stopdurs <- intervals$duration %>% magrittr::extract(. > greatthan)
    movedurs <- REVERSEintervals$duration %>% magrittr::extract(. > greatthan)
    
    #plot the densities of these durations
    if (display) {
      print(
        ggplot() + labs(fill = "type", title = filename) +
          geom_density(data = data.frame(x = freqs), 
                       aes(x = x, fill = "freq"), alpha = 0.4) + 
          geom_density(data = data.frame(y = stopdurs),
                       aes(x = y, fill = "stop"), alpha = 0.4) +
          geom_density(data = data.frame(z = movedurs),
                       aes(x = z, fill = "move"), alpha = 0.4) +
          xlim(-0.01, 1.5) + 
          scale_fill_manual(
            name = "vars", guide = "legend",
            values = c("freq" = "red", "stop" = "yellow", "move" = "blue"),
            labels = c("freq" = "stop-start duration", "stop" = "stop durations", "move" =  "movement durations")) 
        
      )
    }
    
    #return all the values
    list(
      med_freqs = median(freqs),
      sd_freqs = sd(freqs),
      med_stopdurs = median(stopdurs),
      sd_stopdurs = sd(stopdurs),
      med_movedurs = median(movedurs),
      sd_movedurs = sd(movedurs)
    ) %>% return()
  } else {
    
    list(
      med_freqs = NA,
      sd_freqs = NA,
      med_stopdurs = NA,
      sd_stopdurs = NA,
      med_movedurs = NA,
      sd_movedurs = NA
    ) %>% return()
  }
  
}

stat_generator <- function(traj){
  cutoffspeed = 0.05
  filename <- attr(traj, "filename")
  
  #create a list of speeds over time
  ############ Hey! Tracker speeds and TrajR-calculated speeds differ!#######
  traj %>% 
    TrajSmoothSG(p = 1, n = 11) %>%
    TrajDerivatives() %>% pluck("speed") -> smoothspeed
  traj %>% TrajDerivatives() %>% pluck("speed") -> rawspeed
  
  #get the speed ONLY during movement
  movespeed <- rawspeed %>% magrittr::extract(. > cutoffspeed)
  
  #get the stop-start interval variables
  int_vars <- intervaler(traj, display = FALSE)
  
  #Measures of straightness
  sinuosity <- TrajSinuosity(traj)
  resampled <- TrajRediscretize(traj, .001)  #should I pick a different value?
  Emax <- TrajEmax(resampled)
  
  #attempts to get a spectral value...
  
  detspeed <- pracma::detrend(rawspeed)
  #detspeed <- ts(detspeed, frequency = 31536000, start = 0)
  #I'm only getting the index? not useful really
  #spect <- GeneCycle::robust.spectrum(detspeed) 
  dfreqs <- dominant.freqs(detspeed, 3)
  #acf(detspeed, main = filename)
  nobud <- nobu(rawspeed)
  title(filename)
  
  list(
    int_vars,
    med_movespeed = median(movespeed),
    sd_movespeed = sd(movespeed),
    sinuosity = sinuosity,
    Emax = Emax,
    dfreq1 = dfreqs[1],
    dfreq2 = dfreqs[2],
    dfreq3 = dfreqs[3],
    nobu = nobud
  ) %>% flatten() %>% return()
  
}

# Custom PCA plotting function
customPcaPlot <- function(x, xlabs, xcols, choices = 1L:2L, ycol = "#ff2222aa", ...) {
  # Draw points
  pts <- t(t(x$x[, choices]))
  plot(pts, type = "p", 
       xlim = extendrange(pts[, 1L]), ylim = extendrange(pts[, 2L]), 
       asp = 1,
       xlab = "PC1", ylab = "PC2", pch = 16, col = xcols, ...)
  text(pts, labels = xlabs, pos = 1, ...)
  
  # Draw arrows
  axs <- t(t(x$rotation[, choices])) * 3.5
  text(axs, labels = dimnames(axs)[[1L]], col = ycol, ...)
  arrows(0, 0, axs[, 1L] * .8, axs[, 2L] * .8, length = .1, col = ycol)
}

pca_maker <- function(stats, keep.nas = FALSE, excluded.species = NULL, ...){
  col.list <- quos(...)
  
  #remove excluded species
  `%not_in%` <- purrr::negate(`%in%`)
  if (!is.null(excluded.species)) {stats <- stats %>% filter(species %not_in% excluded.species)}
  
  #remove or keep NAs
  if (keep.nas == FALSE) stats <- na.omit(stats);
  
  #remove columns that shouldn't be included
  excluded.cols <- c("individual", "species")
  pca.stats <- stats %>% select(-one_of(excluded.cols))
  
  #select (or not) subset of columns to use
  if (length(col.list) >= 1) pca.stats <- pca.stats %>% select(!!!col.list);
  
  # Perform the PCA
  PCA <- prcomp(pca.stats, scale. = TRUE)
  # Plot it using custom plotting function. Could just call biplot instead
  customPcaPlot(PCA, stats$individual, stats$species, cex = .8)
  #legend("bottomleft", c("Spider", "Mimic", "Ant"), pch = 16, 
  #       col = c('red', 'blue', 'black'), inset = c(0.01, .02))
  
  
  return(PCA)
  
}


}

files <- list.files() %>% str_subset("[_][ABCDEF][.]csv")
trajs <- NULL
for (i in files) {
  print(i)
  
  #create a temp trajectory from the filename
  i %>% cvs_reader_func() %>%
    TrajFromCoords(xCol = "x", yCol = "y", fps = 240, timeUnits = "s") -> traj
  
  #give them a filename attribute (for plotting labels)
  attr(traj, "filename") <- i
  trajs[[i]] <- traj
  
}

stats <- TrajsMergeStats(trajs, stat_generator)
rownames(stats) <- files
stats$species <- row.names(stats) %>% 
  strapplyc("(.+)[0-9]_[A-Z][.]csv") %>% unlist() %>% as.factor()
stats$individual <- row.names(stats) %>% 
  strapplyc("(.+[0-9])_[A-Z][.]csv") %>% unlist() %>% as.factor()


```


Okay! So, let's go over the basics, shall we?

















This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately. 

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r eruptions, echo=FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r tabsets, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package = "shiny"),
  options = list(
    width = "100%", height = 550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.



